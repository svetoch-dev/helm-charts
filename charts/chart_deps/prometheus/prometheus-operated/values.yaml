nameOverride: ""
fullnameOverride: ""

labels: {}

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

service:
  enabled: false
  type: ClusterIP
  annotations: {}
  ports:
    - port: 80
      targetPort: http-web
      protocol: TCP
      name: http

thanosService:
  enabled: false
  type: ClusterIP
  annotations: {}
  ports:
    - port: 8080
      targetPort: grpc
      protocol: TCP
      name: grpc
    - port: 80
      targetPort: http
      protocol: TCP
      name: http

servicemonitor:
  enabled: false
  prometheusSelector: {}
  labels: {}
  targetLabels: []
  #endpoints:
  #  - port: http
  #    path: /metrics

thanosSericeMonitor:
  enabled: false
  prometheusSelector: {}
  labels: {}
  targetLabels: []
  #endpoints:
  #  - port: http
  #    path: /metrics

thanosIngress:
  enabled: false
  className: ""
  service:
    port: 8080
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

ingress:
  enabled: false
  className: ""
  service:
    port: 80
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

prometheus:
  labels: {}
  spec:
    podMetadata: {}

    serviceMonitorSelector:
    serviceMonitorNamespaceSelector: {}

    podMonitorSelector:
    podMonitorNamespaceSelector: {}

    probeSelector:
    probeNamespaceSelector: {}

    ruleSelector:
    ruleNamespaceSelector: {}

    scrapeConfigSelector: {}
    scrapeConfigNamespaceSelector: {}

    paused: false

    image: "quay.io/prometheus/prometheus:v3.9.1"

    version: "v3.9.1"

    imagePullPolicy: IfNotPresent

    imagePullSecrets: []

    replicas: 1

    shards: 1

    replicaExternalLabelName:

    prometheusExternalLabelName:

    logLevel: info

    logFormat: json

    scrapeInterval: "30s"

    scrapeTimeout: "10s"

    externalLabels: {}

    enableRemoteWriteReceiver: false

    enableFeatures: []

    externalUrl: "https://pm.{{ .Values.global.company.domain.env }}"

    routePrefix: "/"

    storage: {}

    volumes: {}

    volumeMounts: {}

    persistentVolumeClaimRetentionPolicy: {}

    web: {}

    resources: {}

    nodeSelector: {}

    secrets: []

    configMaps: []

    affinity: {}

    tolerations: []

    topologySpreadConstraints: []

    remoteWrite: []

    securityContext:
      fsGroup: 2000
      runAsGroup: 2000
      runAsNonRoot: true
      runAsUser: 1000
      seccompProfile:
        type: RuntimeDefault

    listenLocal: false

    containers: []

    initContainers: []

    additionalScrapeConfigs: {}

    apiserverConfig: {}

    priorityClassName:

    portName: "http-web"

    arbitraryFSAccessThroughSMs:

    overrideHonorLabels: false

    overrideHonorTimestamps: false

    ignoreNamespaceSelectors: false

    enforcedNamespaceLabel: ""

    enforcedTargetLimit:

    enforcedLabelLimit:

    enforcedLabelNameLengthLimit:

    enforcedLabelValueLengthLimit:

    enforcedKeepDroppedTargets:

    enforcedBodySizeLimit:

    minReadySeconds: 0

    hostAliases: []

    additionalArgs: []

    walCompression: true

    excludedFromEnforcement: []

    hostNetwork: false

    podTargetLabels: []

    tracingConfig: []

    bodySizeLimit:

    sampleLimit:

    targetLimit:

    labelLimit:

    labelNameLengthLimit:

    labelValueLengthLimit:

    keepDroppedTargets:

    retention: "8h"

    disableCompaction: false

    rules: []

    prometheusRulesExcludedFromEnforce: []

    query: {}

    alerting: {}
  #    alertmanagers:
  #      - name: main-alertmanager
  #        namespace: prometheus
  #        port: http-web

    additionalAlertRelabelConfigs: {}

    additionalAlertManagerConfigs: {}

    remoteRead: []

    thanos:
      blockSize: 2h
      image: quay.io/thanos/thanos:v0.39.2@sha256:1d022ef4b8eff056a0e3b7822f953d931c5704d068413f2d7ce5266aa96c9e80
      version: v0.39.2
      objectStorageConfig:
        name: '{{ include "prometheus-operated.fullname" . }}-thanos'
        key: objstore.yml
      resources:
        limits:
          cpu: 350m
          memory: 150Mi
        requests:
          cpu: 10m
          memory: 35Mi

    queryLogFile:

    exemplars: {}

    evaluationInterval: "30s"

    enableAdminAPI: false

    serviceDiscoveryRole: "EndpointSlice"

    tsdb:
      outOfOrderTimeWindow: 0s


secrets:
  thanos:
    name: thanos
    data:
      objstore.yml: |
        type: "{{ .Values.global.bucket.type | upper }}"
        config:
          bucket: "{{ .Values.global.company.name }}-thanos-{{ .Values.global.env.short_name }}"
